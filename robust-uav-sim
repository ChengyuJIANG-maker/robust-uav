function integrated_drone_gui
    % 创建主窗口
    fig = figure('Name', '无人机路径规划与控制仿真系统', 'NumberTitle', 'off', ...
                 'Position', [50, 50, 900, 700], 'MenuBar', 'none', ...
                 'ToolBar', 'none', 'Resize', 'on');
    
    % 创建主选项卡组
    mainTabGroup = uitabgroup('Parent', fig, 'Position', [0.02, 0.05, 0.96, 0.9]);
    
    % 创建路径规划选项卡
    pathPlanningTab = uitab('Parent', mainTabGroup, 'Title', '路径规划');
    
    % 创建无人机控制选项卡
    droneControlTab = uitab('Parent', mainTabGroup, 'Title', '无人机控制');
    
    % 初始化路径规划参数结构
    pathParams = struct();
    
    % 初始化无人机控制参数结构
    controlParams = struct();
    
    % 创建路径规划界面
    createPathPlanningUI(pathPlanningTab);
    
    % 创建无人机控制界面
    createDroneControlUI(droneControlTab);
    
    % 路径规划界面创建函数
    function createPathPlanningUI(tab)
        % 创建面板容器
        mainPanel = uipanel('Parent', tab, ...
                            'Title', '路径规划参数', ...
                            'Position', [0.02, 0.02, 0.96, 0.96], ...
                            'FontSize', 12, ...
                            'FontWeight', 'bold');
        
        % 地图大小设置
        uicontrol('Parent', mainPanel, ...
                  'Style', 'text', ...
                  'String', '地图大小 [x y z]:', ...
                  'Position', [30, 450, 150, 25], ...
                  'HorizontalAlignment', 'left');
        
        pathParams.mapSizeEdit = uicontrol('Parent', mainPanel, ...
                                          'Style', 'edit', ...
                                          'String', '50 50 20', ...
                                          'Position', [200, 450, 100, 25]);
        
        % 分辨率设置
        uicontrol('Parent', mainPanel, ...
                  'Style', 'text', ...
                  'String', '分辨率 (米/栅格):', ...
                  'Position', [30, 410, 150, 25], ...
                  'HorizontalAlignment', 'left');
        
        pathParams.resolutionEdit = uicontrol('Parent', mainPanel, ...
                                             'Style', 'edit', ...
                                             'String', '1', ...
                                             'Position', [200, 410, 100, 25]);
        
        % 起点设置
        uicontrol('Parent', mainPanel, ...
                  'Style', 'text', ...
                  'String', '起点坐标 [x y z]:', ...
                  'Position', [30, 370, 150, 25], ...
                  'HorizontalAlignment', 'left');
        
        pathParams.startEdit = uicontrol('Parent', mainPanel, ...
                                        'Style', 'edit', ...
                                        'String', '2 2 2', ...
                                        'Position', [200, 370, 100, 25]);
        
        % 终点设置
        uicontrol('Parent', mainPanel, ...
                  'Style', 'text', ...
                  'String', '终点坐标 [x y z]:', ...
                  'Position', [30, 330, 150, 25], ...
                  'HorizontalAlignment', 'left');
        
        pathParams.goalEdit = uicontrol('Parent', mainPanel, ...
                                       'Style', 'edit', ...
                                       'String', '48 48 18', ...
                                       'Position', [200, 330, 100, 25]);
        
        % 障碍物比例设置
        uicontrol('Parent', mainPanel, ...
                  'Style', 'text', ...
                  'String', '障碍物比例 (0-1):', ...
                  'Position', [30, 290, 150, 25], ...
                  'HorizontalAlignment', 'left');
        
        pathParams.obsRatioEdit = uicontrol('Parent', mainPanel, ...
                                           'Style', 'edit', ...
                                           'String', '0.15', ...
                                           'Position', [200, 290, 100, 25]);
        
        % 路径平滑复选框
        pathParams.smoothCheck = uicontrol('Parent', mainPanel, ...
                                          'Style', 'checkbox', ...
                                          'String', '路径平滑', ...
                                          'Value', 1, ...
                                          'Position', [30, 250, 150, 25]);
        
        % 交互式编辑复选框
        pathParams.guiCheck = uicontrol('Parent', mainPanel, ...
                                       'Style', 'checkbox', ...
                                       'String', '交互式障碍物编辑', ...
                                       'Value', 1, ...
                                       'Position', [30, 220, 200, 25]);
        
        % 运行路径规划按钮
        uicontrol('Parent', mainPanel, ...
                  'Style', 'pushbutton', ...
                  'String', '运行路径规划', ...
                  'Position', [150, 150, 200, 40], ...
                  'FontSize', 12, ...
                  'FontWeight', 'bold', ...
                  'Callback', @runPathPlanning);
    end
    
    % 无人机控制界面创建函数
    function createDroneControlUI(tab)
        % 创建嵌套选项卡组
        controlTabGroup = uitabgroup('Parent', tab, 'Position', [0, 0, 1, 0.9]);
        
        % 创建基本参数选项卡
        basicTab = uitab('Parent', controlTabGroup, 'Title', '基本参数');
        controllerTab = uitab('Parent', controlTabGroup, 'Title', '控制器参数');
        environmentTab = uitab('Parent', controlTabGroup, 'Title', '环境参数');
        advancedTab = uitab('Parent', controlTabGroup, 'Title', '高级参数');
        
        % 基本参数选项卡内容
        createBasicTab(basicTab);
        
        % 控制器参数选项卡内容
        createControllerTab(controllerTab);
        
        % 环境参数选项卡内容
        createEnvironmentTab(environmentTab);
        
        % 高级参数选项卡内容
        createAdvancedTab(advancedTab);
        
        % 创建运行仿真按钮
        uicontrol('Style', 'pushbutton', 'String', '运行仿真', ...
                  'Position', [350, 20, 200, 40], ...
                  'Callback', @runDroneSimulation, ...
                  'FontSize', 14, 'FontWeight', 'bold');
        
        % 基本参数选项卡创建函数
        function createBasicTab(tab)
            yPos = 0.9;
            verticalSpacing = 0.07;
            
            % 仿真时间
            uicontrol('Parent', tab, 'Style', 'text', 'String', '仿真时间 (s):', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.simTime = uicontrol('Parent', tab, 'Style', 'edit', 'String', '20', ...
                                             'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 时间步长
            uicontrol('Parent', tab, 'Style', 'text', 'String', '时间步长 (s):', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.dt = uicontrol('Parent', tab, 'Style', 'edit', 'String', '0.01', ...
                                        'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 无人机质量
            uicontrol('Parent', tab, 'Style', 'text', 'String', '无人机质量 (kg):', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.mass = uicontrol('Parent', tab, 'Style', 'edit', 'String', '1.0', ...
                                          'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 初始位置
            uicontrol('Parent', tab, 'Style', 'text', 'String', '初始位置 [x,y,z]:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.initialPos = uicontrol('Parent', tab, 'Style', 'edit', 'String', '[0, 0, 0]', ...
                                                'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 目标位置
            uicontrol('Parent', tab, 'Style', 'text', 'String', '目标位置 [x,y,z]:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.targetPos = uicontrol('Parent', tab, 'Style', 'edit', 'String', '[6, 7, 4]', ...
                                               'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
        end
        
        % 控制器参数选项卡创建函数
        function createControllerTab(tab)
            yPos = 0.9;
            verticalSpacing = 0.07;
            
            % 控制器类型
            uicontrol('Parent', tab, 'Style', 'text', 'String', '控制器类型:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.controllerType = uicontrol('Parent', tab, 'Style', 'popupmenu', ...
                                                    'String', {'PID控制', '自适应PID控制', '滑模控制'}, ...
                                                    'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % PID参数 - Kp
            uicontrol('Parent', tab, 'Style', 'text', 'String', 'PID Kp [xy, z]:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.Kp = uicontrol('Parent', tab, 'Style', 'edit', 'String', '[9.0, 20.0]', ...
                                        'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % PID参数 - Ki
            uicontrol('Parent', tab, 'Style', 'text', 'String', 'PID Ki [xy, z]:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.Ki = uicontrol('Parent', tab, 'Style', 'edit', 'String', '[1.0, 3.0]', ...
                                        'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % PID参数 - Kd
            uicontrol('Parent', tab, 'Style', 'text', 'String', 'PID Kd [xy, z]:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.Kd = uicontrol('Parent', tab, 'Style', 'edit', 'String', '[5.0, 10.0]', ...
                                        'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 自适应率
            uicontrol('Parent', tab, 'Style', 'text', 'String', '自适应率:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.adaptiveRate = uicontrol('Parent', tab, 'Style', 'edit', 'String', '0.2', ...
                                                  'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 滑模控制参数 - lambda
            uicontrol('Parent', tab, 'Style', 'text', 'String', '滑模控制 lambda:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.lambda = uicontrol('Parent', tab, 'Style', 'edit', 'String', '[5, 5, 5]', ...
                                            'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 滑模控制参数 - K
            uicontrol('Parent', tab, 'Style', 'text', 'String', '滑模控制 K:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.K_smc = uicontrol('Parent', tab, 'Style', 'edit', 'String', '[8, 8, 10]', ...
                                           'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
        end
        
        % 环境参数选项卡创建函数
        function createEnvironmentTab(tab)
            yPos = 0.9;
            verticalSpacing = 0.07;
            
            % 平均风速
            uicontrol('Parent', tab, 'Style', 'text', 'String', '平均风速 [x,y,z]:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.windMean = uicontrol('Parent', tab, 'Style', 'edit', 'String', '[1.0, 0.5, 0]', ...
                                              'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 湍流强度
            uicontrol('Parent', tab, 'Style', 'text', 'String', '湍流强度:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.windTurbulence = uicontrol('Parent', tab, 'Style', 'edit', 'String', '0.5', ...
                                                    'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 湍流尺度长度
            uicontrol('Parent', tab, 'Style', 'text', 'String', '湍流尺度长度:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.windScaleLength = uicontrol('Parent', tab, 'Style', 'edit', 'String', '50', ...
                                                     'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 涡流强度
            uicontrol('Parent', tab, 'Style', 'text', 'String', '涡流强度:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.vortexStrength = uicontrol('Parent', tab, 'Style', 'edit', 'String', '0.3', ...
                                                    'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 涡流中心
            uicontrol('Parent', tab, 'Style', 'text', 'String', '涡流中心 [x,y,z]:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.vortexCenter = uicontrol('Parent', tab, 'Style', 'edit', 'String', '[5, 3, 2]', ...
                                                  'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 涡流半径
            uicontrol('Parent', tab, 'Style', 'text', 'String', '涡流半径:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.vortexRadius = uicontrol('Parent', tab, 'Style', 'edit', 'String', '3', ...
                                                  'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
        end
        
        % 高级参数选项卡创建函数
        function createAdvancedTab(tab)
            yPos = 0.9;
            verticalSpacing = 0.07;
            
            % 位置噪声标准差
            uicontrol('Parent', tab, 'Style', 'text', 'String', '位置噪声标准差:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.posNoiseStd = uicontrol('Parent', tab, 'Style', 'edit', 'String', '0.01', ...
                                                 'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 速度噪声标准差
            uicontrol('Parent', tab, 'Style', 'text', 'String', '速度噪声标准差:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.velNoiseStd = uicontrol('Parent', tab, 'Style', 'edit', 'String', '0.05', ...
                                                 'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 风速噪声标准差
            uicontrol('Parent', tab, 'Style', 'text', 'String', '风速噪声标准差:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.windNoiseStd = uicontrol('Parent', tab, 'Style', 'edit', 'String', '0.1', ...
                                                  'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 阻力系数
            uicontrol('Parent', tab, 'Style', 'text', 'String', '阻力系数:', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.Cd = uicontrol('Parent', tab, 'Style', 'edit', 'String', '0.5', ...
                                        'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
            yPos = yPos - verticalSpacing;
            
            % 特征面积
            uicontrol('Parent', tab, 'Style', 'text', 'String', '特征面积 (m^2):', ...
                      'Units', 'normalized', 'Position', [0.1, yPos, 0.3, 0.05], ...
                      'HorizontalAlignment', 'left');
            controlParams.A = uicontrol('Parent', tab, 'Style', 'edit', 'String', '0.1', ...
                                       'Units', 'normalized', 'Position', [0.5, yPos, 0.3, 0.05]);
        end
    end
    
    % 运行路径规划回调函数
    function runPathPlanning(~, ~)
        try
            % 从界面获取参数
            mapSize = str2num(get(pathParams.mapSizeEdit, 'String'));
            resolution = str2double(get(pathParams.resolutionEdit, 'String'));
            start = str2num(get(pathParams.startEdit, 'String'));
            goal = str2num(get(pathParams.goalEdit, 'String'));
            obsRatio = str2double(get(pathParams.obsRatioEdit, 'String'));
            useSmooth = get(pathParams.smoothCheck, 'Value');
            useGUI = get(pathParams.guiCheck, 'Value');
            
            % 验证输入
            if length(mapSize) ~= 3 || any(mapSize <= 0)
                errordlg('地图大小必须是三个正整数值', '输入错误');
                return;
            end
            
            if resolution <= 0
                errordlg('分辨率必须是正数', '输入错误');
                return;
            end
            
            if length(start) ~= 3 || any(start < 1) || any(start > mapSize)
                errordlg('起点坐标必须在有效范围内', '输入错误');
                return;
            end
            
            if length(goal) ~= 3 || any(goal < 1) || any(goal > mapSize)
                errordlg('终点坐标必须在有效范围内', '输入错误');
                return;
            end
            
            if obsRatio < 0 || obsRatio > 1
                errordlg('障碍物比例必须在0到1之间', '输入错误');
                return;
            end
            
            % 运行主算法
            runPathPlanningAlgorithm(mapSize, resolution, start, goal, obsRatio, useSmooth, useGUI);
            
        catch ME
            errordlg(sprintf('输入参数错误: %s', ME.message), '输入错误');
        end
    end
    
    % 运行无人机控制仿真回调函数
    function runDroneSimulation(~, ~)
        % 从GUI获取参数
        simParams.T = str2double(get(controlParams.simTime, 'String'));
        simParams.dt = str2double(get(controlParams.dt, 'String'));
        simParams.mass = str2double(get(controlParams.mass, 'String'));
        simParams.initialPos = str2num(get(controlParams.initialPos, 'String')); %#ok<ST2NM>
        simParams.targetPos = str2num(get(controlParams.targetPos, 'String')); %#ok<ST2NM>
        
        % 控制器参数
        simParams.controller_type = get(controlParams.controllerType, 'Value');
        KpValues = str2num(get(controlParams.Kp, 'String')); %#ok<ST2NM>
        KiValues = str2num(get(controlParams.Ki, 'String')); %#ok<ST2NM>
        KdValues = str2num(get(controlParams.Kd, 'String')); %#ok<ST2NM>
        simParams.Kp_xy0 = KpValues(1);
        simParams.Kp_z0 = KpValues(2);
        simParams.Ki_xy0 = KiValues(1);
        simParams.Ki_z0 = KiValues(2);
        simParams.Kd_xy0 = KdValues(1);
        simParams.Kd_z0 = KdValues(2);
        simParams.adaptive_rate = str2double(get(controlParams.adaptiveRate, 'String'));
        simParams.lambda = diag(str2num(get(controlParams.lambda, 'String'))); %#ok<ST2NM>
        simParams.K_smc = diag(str2num(get(controlParams.K_smc, 'String'))); %#ok<ST2NM>
        
        % 环境参数
        simParams.wind_mean = str2num(get(controlParams.windMean, 'String'))'; %#ok<ST2NM>
        simParams.wind_turbulence_intensity = str2double(get(controlParams.windTurbulence, 'String'));
        simParams.wind_scale_length = str2double(get(controlParams.windScaleLength, 'String'));
        simParams.vortex_strength = str2double(get(controlParams.vortexStrength, 'String'));
        simParams.vortex_center = str2num(get(controlParams.vortexCenter, 'String'))'; %#ok<ST2NM>
        simParams.vortex_radius = str2double(get(controlParams.vortexRadius, 'String'));
        
        % 高级参数
        simParams.pos_noise_std = str2double(get(controlParams.posNoiseStd, 'String'));
        simParams.vel_noise_std = str2double(get(controlParams.velNoiseStd, 'String'));
        simParams.wind_noise_std = str2double(get(controlParams.windNoiseStd, 'String'));
        simParams.Cd = str2double(get(controlParams.Cd, 'String'));
        simParams.A = str2double(get(controlParams.A, 'String'));
        
        % 调用修改后的仿真函数
        advanced_drone_control_simulation_with_params(simParams);
    end
    
    % 路径规划算法函数
    function runPathPlanningAlgorithm(mapSize, resolution, start, goal, obsRatio, useSmooth, useGUI)
        % 初始化地图
        map = zeros(mapSize);
        fprintf('正在生成 %d%% 随机障碍物...\n', round(obsRatio*100));
        N = round(prod(mapSize)*obsRatio);
        while nnz(map) < N
            % 分别为 x/y/z 指定随机范围
            obs = [randi([1 mapSize(1)]), ...
                   randi([1 mapSize(2)]), ...
                   randi([1 mapSize(3)])];
            sz  = randi([2 4],1,3);
            map = addBoxObs(map, obs-sz, obs+sz);
        end

        % 交互式编辑障碍物
        if useGUI
            % 新建普通 figure，避免 Dock 或 App 模式
            hFig = figure('Name','双击增删障碍物，回车继续', ...
                          'NumberTitle','off', ...
                          'DockControls','off', ...
                          'MenuBar','none', ...
                          'ToolBar','none');
            ax   = axes('Parent',hFig,'NextPlot','add');
            showMap3D(map,start,goal,ax);
            view(3); grid on; axis equal;

            % 关闭冲突的交互工具
            rotate3d(ax,'off'); zoom(ax,'off'); pan(ax,'off');

            % 监听鼠标双击
            set(hFig,'WindowButtonDownFcn',@mouseCallback);
            set(hFig,'KeyPressFcn',@keyCallback);

            fprintf('双击图中任意位置增删障碍物（3×3×3 块），按回车继续...\n');
            uiwait(hFig);           % 等待回车
            close(hFig);            % 安全关闭
        end

        % A* 搜索
        tic;
        [path, expand] = Astar3D(map, start, goal);
        tCost = toc;
        if isempty(path)
            error('未找到可行路径！请减少障碍物或调整起终点。');
        end

        % 路径后处理
        origLen = pathLength(path);
        if useSmooth
            path = smoothPath(path, map);
        end
        smoothLen = pathLength(path);

        % 可视化结果
        fprintf('A* 完成！扩展节点: %d, 耗时: %.3fs\n', size(expand,1), tCost);
        fprintf('原始长度: %.2f m, 平滑后: %.2f m\n', origLen*resolution, smoothLen*resolution);

        % 强制新建独立窗口，并置顶
        fig3d = figure('Name','3D 航迹', ...
                       'NumberTitle','off', ...
                       'WindowState','normal', ...
                       'Position',[360 240 800 600]);
        ax3d  = axes('Parent',fig3d);
        showMap3D(map,start,goal,ax3d); hold(ax3d,'on');
        plot3(ax3d,expand(:,1),expand(:,2),expand(:,3),'y.','MarkerSize',2);
        plot3(ax3d,path(:,1),path(:,2),path(:,3),'r','LineWidth',2);
        plot3(ax3d,path(:,1),path(:,2),path(:,3),'go','MarkerSize',4,'MarkerFaceColor','g');
        view(ax3d,3); grid(ax3d,'on'); axis equal; rotate3d on;
        legend(ax3d,'障碍物','起点','终点','A* 扩展节点','航迹','航点');

        % 2D 投影补充视图
        figure('Name','俯视 / 侧视投影');
        subplot(1,2,1); imagesc(squeeze(any(map,3))'); colormap(gray); axis equal ij;
        hold on; plot(path(:,1),path(:,2),'r','LineWidth',2);
        plot(start(1),start(2),'go','MarkerSize',8,'MarkerFace','g');
        plot(goal(1), goal(2), 'rx','MarkerSize',10,'LineWidth',2);
        title('俯视图 (XY)'); xlabel('X'); ylabel('Y');

        subplot(1,2,2); imagesc(squeeze(any(map,2))'); colormap(gray); axis equal ij;
        hold on; plot(path(:,1),path(:,3),'r','LineWidth',2);
        plot(start(1),start(3),'go','MarkerSize',8,'MarkerFace','g');
        plot(goal(1), goal(3), 'rx','MarkerSize',10,'LineWidth',2);
        title('侧视图 (XZ)'); xlabel('X'); ylabel('Z');
    end

    % 子函数定义
    function map = addBoxObs(map,c1,c2)
        % 将长方体区域标记为障碍
        c1 = max(ceil(c1),1); c2 = min(floor(c2),size(map));
        map(c1(1):c2(1),c1(2):c2(2),c1(3):c2(3)) = 1;
    end

    function showMap3D(map,start,goal,ax)
        if nargin<4 || isempty(ax); figure; ax = axes; end
        % 绘制障碍物
        [x,y,z] = ind2sub(size(map),find(map==1));
        scatter3(x,y,z,30,'filled','MarkerFaceColor',[0.3 0.3 0.3],'Parent',ax);
        hold(ax,'on');
        scatter3(start(1),start(2),start(3),80,'go','MarkerFaceColor','g','Parent',ax);
        scatter3(goal(1),goal(2),goal(3),80,'rx','MarkerFaceColor','r','Parent',ax);
    end

    function [path,expand] = Astar3D(map,start,goal)
        % 三维 A* 算法
        start = double(start); goal = double(goal);
        mapSize = size(map);
        dirs = [0 0 0; ...
                1 0 0;-1 0 0; 0 1 0; 0 -1 0; 0 0 1; 0 0 -1; ...
                1 1 0;1 -1 0;-1 1 0;-1 -1 0; ...
                1 0 1;1 0 -1;-1 0 1;-1 0 -1; ...
                0 1 1;0 1 -1;0 -1 1;0 -1 -1; ...
                1 1 1;1 1 -1;1 -1 1;1 -1 -1;-1 1 1;-1 1 -1;-1 -1 1;-1 -1 -1];
        cost = sqrt(sum(dirs.^2,2)); % 欧氏距离代价
        dirs = dirs';
        N = size(dirs,2);

        % 初始化
        openSet = start;                 % 开放列表
        gScore  = inf(prod(mapSize),1);  % 线性索引
        fScore  = gScore;
        parent  = zeros(prod(mapSize),1);
        idxS = sub2ind(mapSize,start(1),start(2),start(3));
        idxG = sub2ind(mapSize,goal(1),goal(2),goal(3));
        gScore(idxS) = 0;
        fScore(idxS) = norm(start-goal);

        expand = []; % 记录扩展节点用于可视化

        while ~isempty(openSet)
            % 选取 fScore 最小节点
            [~,idx] = min(fScore(sub2ind(mapSize,openSet(:,1),openSet(:,2),openSet(:,3))));
            current = openSet(idx,:);
            idxC = sub2ind(mapSize,current(1),current(2),current(3));

            % 到达目标
            if isequal(current,goal)
                path = reconstructPath(parent,idxC,mapSize);
                path = path(end:-1:1,:);
                return;
            end

            openSet(idx,:) = [];
            fScore(idxC) = inf;
            expand(end+1,:) = current;

            % 遍历 26 邻域
            for k = 1:N
                neighbor = current + dirs(:,k)';
                if any(neighbor<1 | neighbor>mapSize) || map(neighbor(1),neighbor(2),neighbor(3))
                    continue; % 越界或障碍
                end
                idxN = sub2ind(mapSize,neighbor(1),neighbor(2),neighbor(3));
                tentG = gScore(idxC) + cost(k);
                if tentG < gScore(idxN)
                    parent(idxN) = idxC;
                    gScore(idxN) = tentG;
                    fScore(idxN) = tentG + norm(neighbor-goal);
                    if ~any(ismember(openSet,neighbor,'rows'))
                        openSet(end+1,:) = neighbor;
                    end
                end
            end
        end
        path = []; % 无路径
    end

    function path = reconstructPath(parent,idx,mapSize)
        % 从终点回溯到起点
        path = [];
        while idx ~= 0
            [x,y,z] = ind2sub(mapSize,idx);
            path(end+1,:) = [x y z];
            idx = parent(idx);
        end
    end

    function d = pathLength(path)
        % 计算路径长度
        d = sum(sqrt(sum(diff(path).^2,2)));
    end

    function path = smoothPath(path,map)
        % 简单共线剪枝 + 三次样条平滑
        % 1. 共线剪枝
        idx = 1;
        for k = 2:size(path,1)-1
            v1 = path(k,:) - path(idx,:);
            v2 = path(k+1,:) - path(k,:);
            if abs(dot(v1,v2)/(norm(v1)*norm(v2)+eps) - 1) < 1e-3
                continue;
            else
                idx = idx+1;
                path(idx,:) = path(k,:);
            end
        end
        path(idx+1,:) = path(end,:);
        path = path(1:idx+1,:);

        % 2. 三次样条平滑
        t = 1:size(path,1);
        ts = linspace(1,size(path,1),5*size(path,1));
        path = [spline(t,path(:,1),ts)' spline(t,path(:,2),ts)' spline(t,path(:,3),ts)'];
        % 检查碰撞
        for k = 2:size(path,1)
            p = round(path(k,:));
            if any(p<1) || any(p>size(map)) || map(p(1),p(2),p(3))
                % 有碰撞则回退到原始离散路径
                path = round(path);
                break;
            end
        end
    end

    %% --------- 交互回调 ----------
    function mouseCallback(src,~)
        % 双击增删障碍物
        if strcmp(get(src,'SelectionType'),'normal')   % 左键双击
            pt = get(gca,'CurrentPoint');              % [x y z]
            pt = round(pt(1,1:3));
            map = evalin('base','map');                % 从主工作区获取变量
            mapSize = size(map);
            if all(pt>=1 & pt<=mapSize)
                % 切换 3×3×3 区域
                c1 = max(pt-1,1);
                c2 = min(pt+1,mapSize);
                map(c1(1):c2(1),c1(2):c2(2),c1(3):c2(3)) = ...
                    1 - map(c1(1),c1(2),c1(3));        % 0↔1
                assignin('base','map',map);            % 写回工作区
                % 刷新图形
                cla; showMap3D(map,evalin('base','start'),evalin('base','goal'),gca);
                view(3); grid on; axis equal;
            end
        end
    end

    function keyCallback(src,evt)
        if strcmp(evt.Key,'return')
            uiresume(src);
        end
    end
end

% 保留原有的辅助函数 (PID控制器、自适应PID控制器、滑模控制器、扩展卡尔曼滤波器)
function acc_desired = pid_controller(error, error_int, error_deriv, Kp, Ki, Kd, g)
    acc_desired = zeros(3, 1);
    
    % XY平面控制
    acc_desired(1) = Kp(1) * error(1) + Ki(1) * error_int(1) + Kd(1) * error_deriv(1);
    acc_desired(2) = Kp(2) * error(2) + Ki(2) * error_int(2) + Kd(2) * error_deriv(2);
    
    % 高度控制 (Z方向)
    acc_desired(3) = Kp(3) * error(3) + Ki(3) * error_int(3) + Kd(3) * error_deriv(3) + g;
end

function [acc_desired, Kp_new, Ki_new, Kd_new] = adaptive_pid_controller(...
    error, error_int, error_deriv, Kp, Ki, Kd, g, adaptive_rate, dt)
    
    % 根据误差大小调整增益
    error_norm = norm(error);
    
    % 自适应调整规则
    Kp_new = Kp + adaptive_rate * error_norm * [1; 1; 1.5]; % Z方向增益调整更大
    Ki_new = Ki + adaptive_rate * norm(error_int) * [0.5; 0.5; 1];
    Kd_new = Kd + adaptive_rate * norm(error_deriv) * [1; 1; 2];
    
    % 限制增益范围
    Kp_new = min(max(Kp_new, [2; 2; 5]), [30; 30; 40]);
    Ki_new = min(max(Ki_new, [0.1; 0.1; 0.5]), [5; 5; 8]);
    Kd_new = min(max(Kd_new, [2; 2; 5]), [20; 20; 30]);
    
    % 计算控制输出
    acc_desired = pid_controller(error, error_int, error_deriv, Kp_new, Ki_new, Kd_new, g);
end

function acc_desired = sliding_mode_controller(...
    pos, vel, target_pos, target_vel, lambda, K, g)
    
    % 计算误差
    pos_error = target_pos - pos;
    vel_error = target_vel - vel;
    
    % 滑模面
    s = vel_error + lambda * pos_error;
    
    % 滑模控制律
    acc_desired = lambda * vel_error + K * sign(s) + [0; 0; g];
end

function [x_est, P_est] = extended_kalman_filter(x_est, P_est, u, z, dt, Q, R)
    % 状态向量: [x; y; z; vx; vy; vz; wx; wy; wz]
    % 控制输入: 加速度 [ax; ay; az]
    % 测量: [x; y; z; vx; vy; vz]
    
    % 预测步骤
    % 状态转移函数
    f = @(x) [
        x(1) + x(4)*dt;
        x(2) + x(5)*dt;
        x(3) + x(6)*dt;
        x(4) + u(1)*dt;
        x(5) + u(2)*dt;
        x(6) + u(3)*dt;
        x(7); % 风速假设为常数
        x(8);
        x(9)
    ];
    
    % 状态转移雅可比矩阵
    F = [
        1, 0, 0, dt, 0, 0, 0, 0, 0;
        0, 1, 0, 0, dt, 0, 0, 0, 0;
        0, 0, 1, 0, 0, dt, 0, 0, 0;
        0, 0, 0, 1, 0, 0, 0, 0, 0;
        0, 0, 0, 0, 1, 0, 0, 0, 0;
        0, 0, 0, 0, 0, 1, 0, 0, 0;
        0, 0, 0, 0, 0, 0, 1, 0, 0;
        0, 0, 0, 0, 0, 0, 0, 1, 0;
        0, 0, 0, 0, 0, 0, 0, 0, 1
    ];
    
    % 预测状态和协方差
    x_pred = f(x_est);
    P_pred = F * P_est * F' + Q;
    
    % 更新步骤
    % 测量函数
    h = @(x) [x(1:6)]; % 只测量位置和速度
    
    % 测量雅可比矩阵
    H = [
        1, 0, 0, 0, 0, 0, 0, 0, 0;
        0, 1, 0, 0, 0, 0, 0, 0, 0;
        0, 0, 1, 0, 0, 0, 0, 0, 0;
        0, 0, 0, 1, 0, 0, 0, 0, 0;
        0, 0, 0, 0, 1, 0, 0, 0, 0;
        0, 0, 0, 0, 0, 1, 0, 0, 0
    ];
    
    % 卡尔曼增益
    K_gain = P_pred * H' / (H * P_pred * H' + R);
    
    % 更新状态和协方差
    x_est = x_pred + K_gain * (z - h(x_pred));
    P_est = (eye(9) - K_gain * H) * P_pred;
end

% 修改后的仿真函数，接受参数结构体
function advanced_drone_control_simulation_with_params(params)
    % 初始化仿真参数
    dt = params.dt;          % 时间步长
    T = params.T;            % 总仿真时间
    t = 0:dt:T;              % 时间向量
    n = length(t);           % 时间步数
    
    % 无人机参数
    mass = params.mass;      % 质量 (kg)
    g = 9.81;                % 重力加速度 (m/s^2)
    rho = 1.225;             % 空气密度 (kg/m^3)
    Cd = params.Cd;          % 阻力系数
    A = params.A;            % 特征面积 (m^2)
    I = diag([0.01, 0.01, 0.02]); % 惯性矩 
    
    % 控制器参数
    controller_type = params.controller_type; % 1: PID, 2: 自适应PID, 3: 滑模控制
    
    % 基础PID参数
    Kp_z0 = params.Kp_z0;
    Ki_z0 = params.Ki_z0;
    Kd_z0 = params.Kd_z0;
    
    Kp_xy0 = params.Kp_xy0;
    Ki_xy0 = params.Ki_xy0;
    Kd_xy0 = params.Kd_xy0;
    
    % 自适应参数
    adaptive_rate = params.adaptive_rate;
    
    % 滑模控制参数
    lambda = params.lambda;  % 滑模面参数
    K_smc = params.K_smc;    % 滑模控制增益
    
    %% 环境参数设置
    % 风场参数
    wind_mean = params.wind_mean;            % 平均风速 [x; y; z]
    wind_turbulence_intensity = params.wind_turbulence_intensity; % 湍流强度
    wind_scale_length = params.wind_scale_length; % 湍流尺度长度
    
    % 涡流参数
    vortex_strength = params.vortex_strength;
    vortex_center = params.vortex_center;
    vortex_radius = params.vortex_radius;
    
    % 传感器参数
    pos_noise_std = params.pos_noise_std;   % 位置测量噪声标准差
    vel_noise_std = params.vel_noise_std;   % 速度测量噪声标准差
    wind_noise_std = params.wind_noise_std; % 风速测量噪声标准差
    
    % 卡尔曼滤波器参数
    Q_kf = diag([0.01, 0.01, 0.01, 0.05, 0.05, 0.05, 0.1, 0.1, 0.1]); % 过程噪声协方差
    R_kf = diag([0.01, 0.01, 0.01, 0.05, 0.05, 0.05]); % 测量噪声协方差
    
    % 初始状态
    pos = params.initialPos(:);  % 真实位置 [x; y; z]
    vel = [0; 0; 0];             % 真实速度
    acc = [0; 0; 0];             % 真实加速度
    quat = [1; 0; 0; 0];         % 四元数表示姿态 (w, x, y, z)
    
    % 估计状态 (用于卡尔曼滤波)
    x_est = [pos; vel; zeros(3,1)]; % [位置; 速度; 风扰动]
    P_est = eye(9);     % 估计误差协方差
    
    % 目标位置
    target_pos = params.targetPos(:); % [x; y; z]
    target_vel = [0; 0; 0];           % 目标速度
    
    % 存储历史数据
    pos_history = zeros(3, n);
    vel_history = zeros(3, n);
    target_history = zeros(3, n);
    wind_history = zeros(3, n);
    control_history = zeros(3, n);
    estimated_wind_history = zeros(3, n);
    pos_measured_history = zeros(3, n);
    Kp_history = zeros(3, n);
    Ki_history = zeros(3, n);
    Kd_history = zeros(3, n);
    
    % 控制误差
    error_int = [0; 0; 0];  % 积分误差
    prev_error = [0; 0; 0]; % 上一次误差
    
    % 初始化风场
    wind_turbulence = zeros(3, 1);
    
    % 自适应控制器参数
    Kp = [Kp_xy0; Kp_xy0; Kp_z0];
    Ki = [Ki_xy0; Ki_xy0; Ki_z0];
    Kd = [Kd_xy0; Kd_xy0; Kd_z0];
    
    % 主仿真循环
    for i = 1:n
        % 计算当前风场 (Dryden湍流模型 + 涡流)
        if i > 1
            wind_turbulence = (1 - dt/wind_scale_length) * wind_turbulence + ...
                sqrt(2*dt/wind_scale_length) * wind_turbulence_intensity * randn(3, 1);
        end
        
        % 添加涡流效应
        vortex_vec = pos - vortex_center;
        vortex_dist = norm(vortex_vec);
        if vortex_dist > 0 && vortex_dist < vortex_radius
            % 涡流速度场 
            vortex_strength_current = vortex_strength * (1 - vortex_dist/vortex_radius);
            vortex_velocity = cross([0; 0; 1], vortex_vec) * vortex_strength_current / vortex_dist;
            wind_turbulence = wind_turbulence + vortex_velocity;
        end
        
        wind_velocity = wind_mean + wind_turbulence;
        wind_history(:, i) = wind_velocity;
        
        % 存储当前真实状态
        pos_history(:, i) = pos;
        vel_history(:, i) = vel;
        target_history(:, i) = target_pos;
        
        % 传感器测量 (添加噪声)
        pos_measured = pos + pos_noise_std * randn(3, 1);
        vel_measured = vel + vel_noise_std * randn(3, 1);
        wind_measured = wind_velocity + wind_noise_std * randn(3, 1);
        
        pos_measured_history(:, i) = pos_measured;
        
        % 卡尔曼滤波器 - 状态估计
        [x_est, P_est] = extended_kalman_filter(...
            x_est, P_est, acc, [pos_measured; vel_measured], dt, Q_kf, R_kf);
        
        estimated_wind = x_est(7:9);
        estimated_wind_history(:, i) = estimated_wind;
        
        % 计算误差 (使用估计的状态)
        pos_est = x_est(1:3);
        vel_est = x_est(4:6);
        
        error = target_pos - pos_est;
        error_int = error_int + error * dt;
        error_deriv = (error - prev_error) / dt;
        
        % 根据控制器类型选择控制策略
        switch controller_type
            case 1 % PID控制
                acc_desired = pid_controller(error, error_int, error_deriv, Kp, Ki, Kd, g);
                
            case 2 % 自适应PID控制
                [acc_desired, Kp, Ki, Kd] = adaptive_pid_controller(...
                    error, error_int, error_deriv, Kp, Ki, Kd, g, adaptive_rate, dt);
                
                % 存储自适应参数
                Kp_history(:, i) = Kp;
                Ki_history(:, i) = Ki;
                Kd_history(:, i) = Kd;
                
            case 3 % 滑模控制
                acc_desired = sliding_mode_controller(...
                    pos_est, vel_est, target_pos, target_vel, lambda, K_smc, g);
                
            otherwise
                acc_desired = pid_controller(error, error_int, error_deriv, Kp, Ki, Kd, g);
        end
        
        % 添加前馈风补偿
        acc_desired = acc_desired + 0.5 * estimated_wind;
        
        % 计算风阻力
        relative_vel = wind_velocity - vel;
        wind_force = 0.5 * rho * Cd * A * norm(relative_vel) * relative_vel;
        
        % 更新状态 (考虑风阻力)
        control_force = mass * acc_desired;
        total_force = control_force + wind_force - [0; 0; mass*g]; % 控制力 + 风阻力 - 重力
        
        acc = total_force / mass;
        vel = vel + acc * dt;
        pos = pos + vel * dt;
        
        % 存储控制信号
        control_history(:, i) = acc_desired;
        
        % 确保无人机不穿过地面
        if pos(3) < 0
            pos(3) = 0;
            vel(3) = max(0, vel(3)); % 只允许向上反弹
        end
        
        % 更新误差
        prev_error = error;
        
        % 随时间改变目标位置，展示追踪能力
        if i == round(n/6)
            target_pos = [1; -1; 2];
        elseif i == round(2*n/6)
            target_pos = [-1; 2; 4];
        elseif i == round(3*n/6)
            target_pos = [0; 0; 1];
        elseif i == round(4*n/6)
            target_pos = [3; -2; 2];
        elseif i == round(5*n/6)
            target_pos = [-2; 3; 3];
        end
    end
    
    % 绘制结果
    figure('Position', [50, 50, 1600, 1000]);
    
    % 3D轨迹图
    subplot(3, 4, [1, 5]);
    plot3(pos_history(1, :), pos_history(2, :), pos_history(3, :), 'b-', 'LineWidth', 2);
    hold on;
    plot3(target_history(1, :), target_history(2, :), target_history(3, :), 'r--', 'LineWidth', 2);
    plot3(pos_measured_history(1, :), pos_measured_history(2, :), pos_measured_history(3, :), 'g:', 'LineWidth', 1);
    scatter3(target_history(1, 1), target_history(2, 1), target_history(3, 1), 100, 'g', 'filled');
    scatter3(target_history(1, end), target_history(2, end), target_history(3, end), 100, 'r', 'filled');
    
    % 绘制涡流区域
    [x_vortex, y_vortex, z_vortex] = sphere(20);
    x_vortex = vortex_center(1) + vortex_radius * x_vortex;
    y_vortex = vortex_center(2) + vortex_radius * y_vortex;
    z_vortex = vortex_center(3) + vortex_radius * z_vortex;
    surf(x_vortex, y_vortex, z_vortex, 'FaceAlpha', 0.2, 'EdgeColor', 'none', 'FaceColor', 'm');
    
    grid on;
    xlabel('X (m)');
    ylabel('Y (m)');
    zlabel('Z (m)');
    title('无人机3D轨迹 (含风扰动和涡流)');
    legend('真实轨迹', '目标轨迹', '测量轨迹', '起始点', '终点', '涡流区域');
    axis equal;
    
    % 位置随时间变化
    subplot(3, 4, 2);
    plot(t, pos_history(1, :), 'r-', 'LineWidth', 2);
    hold on;
    plot(t, pos_history(2, :), 'g-', 'LineWidth', 2);
    plot(t, pos_history(3, :), 'b-', 'LineWidth', 2);
    plot(t, target_history(1, :), 'r--', 'LineWidth', 1.5);
    plot(t, target_history(2, :), 'g--', 'LineWidth', 1.5);
    plot(t, target_history(3, :), 'b--', 'LineWidth', 1.5);
    
    grid on;
    xlabel('时间 (s)');
    ylabel('位置 (m)');
    title('位置 vs 时间');
    legend('X', 'Y', 'Z', '目标X', '目标Y', '目标Z');
    
    % 速度随时间变化
    %subplot(3, 4, 6);
    %plot(t, vel_history(1, :), 'r-', 'LineWidth', 2);
    %hold on;
    %plot(t, vel_history(2, :), 'g-', 'LineWidth', 2);
    %plot(t, vel_history(3, :), 'b-', 'LineWidth', 2);
    
    %grid on;
    %xlabel('时间 (s)');
    %ylabel('速度 (m/s)');
    %title('速度 vs 时间');
    %legend('V_x', 'V_y', 'V_z');
    
    % XY平面轨迹
    subplot(3, 4, 3);
    plot(pos_history(1, :), pos_history(2, :), 'b-', 'LineWidth', 2);
    hold on;
    plot(target_history(1, :), target_history(2, :), 'r--', 'LineWidth', 2);
    plot(pos_measured_history(1, :), pos_measured_history(2, :), 'g:', 'LineWidth', 1);
    
    % 绘制涡流区域在XY平面的投影
    theta = 0:0.1:2*pi;
    x_vortex_proj = vortex_center(1) + vortex_radius * cos(theta);
    y_vortex_proj = vortex_center(2) + vortex_radius * sin(theta);
    fill(x_vortex_proj, y_vortex_proj, 'm', 'FaceAlpha', 0.2, 'EdgeColor', 'm');
    
    grid on;
    xlabel('X (m)');
    ylabel('Y (m)');
    title('XY平面轨迹');
    legend('真实轨迹', '目标轨迹', '测量轨迹', '涡流区域');
    axis equal;
    
    % 高度随时间变化
    subplot(3, 4, 7);
    plot(t, pos_history(3, :), 'b-', 'LineWidth', 2);
    hold on;
    plot(t, target_history(3, :), 'r--', 'LineWidth', 2);
    plot(t, pos_measured_history(3, :), 'g:', 'LineWidth', 1);
    
    grid on;
    xlabel('时间 (s)');
    ylabel('高度 Z (m)');
    title('高度 vs 时间');
    legend('真实高度', '目标高度', '测量高度');
    
    % 控制信号
     % subplot(3, 4, 11);
     % plot(t, control_history(1, :), 'r-', 'LineWidth', 2);
     % hold on;
     % plot(t, control_history(2, :), 'g-', 'LineWidth', 2);
     % plot(t, control_history(3, :), 'b-', 'LineWidth', 2);
    
     % grid on;
     % xlabel('时间 (s)');
     % ylabel('控制加速度 (m/s^2)');
     % title('控制信号');
     % legend('a_x', 'a_y', 'a_z');
    
    % 位置误差
    subplot(3, 4, 4);
    pos_error = sqrt(sum((pos_history - target_history).^2, 1));
    plot(t, pos_error, 'k-', 'LineWidth', 2);
    
    grid on;
    xlabel('时间 (s)');
    ylabel('位置误差 (m)');
    title('位置误差 vs 时间');
    
    % 自适应参数变化 (如果使用自适应控制)
    if controller_type == 2
        subplot(3, 4, 8);
        plot(t, Kp_history(1, :), 'r-', 'LineWidth', 2);
        hold on;
        plot(t, Kp_history(2, :), 'g-', 'LineWidth', 2);
        plot(t, Kp_history(3, :), 'b-', 'LineWidth', 2);
        
        grid on;
        xlabel('时间 (s)');
        ylabel('比例增益');
        title('自适应Kp参数');
        legend( 'Kp_y', 'Kp_z');
        
        subplot(3, 4, 12);
        plot(t, Ki_history(1, :), 'r-', 'LineWidth', 2);
        hold on;
        plot(t, Ki_history(2, :), 'g-', 'LineWidth', 2);
        plot(t, Ki_history(3, :), 'b-', 'LineWidth', 2);
        
        grid on;
        xlabel('时间 (s)');
        ylabel('积分增益');
        title('自适应Ki参数');
        legend( 'Ki_y', 'Ki_z');
    end
    
    % 添加整体标题
    controller_names = {'PID', '自适应PID', '滑模控制'};
    sgtitle(sprintf('高级无人机控制仿真 - %s控制器 ', ...
        controller_names{controller_type}), 'FontSize', 16);
    
    % 显示无人机性能指标
    fprintf('无人机控制仿真完成!\n');
    fprintf('控制器类型: %s\n', controller_names{controller_type});
    fprintf('最终位置: [%.2f, %.2f, %.2f] m\n', pos(1), pos(2), pos(3));
    fprintf('目标位置: [%.2f, %.2f, %.2f] m\n', target_pos(1), target_pos(2), target_pos(3));
    fprintf('位置误差: %.2f m\n', norm(pos - target_pos));
    
    % 计算性能指标
    position_error = sqrt(sum((pos_history - target_history).^2, 1));
    mean_error = mean(position_error);
    max_error = max(position_error);
    fprintf('平均位置误差: %.2f m\n', mean_error);
    fprintf('最大位置误差: %.2f m\n', max_error);
    
    % 计算风估计误差
    wind_error = sqrt(sum((wind_history - estimated_wind_history).^2, 1));
    mean_wind_error = mean(wind_error);
    fprintf('平均风估计误差: %.2f m/s\n', mean_wind_error);
end
